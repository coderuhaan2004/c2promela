[
    "init {\n  run func1();\n  run func2();\n  run func3();\n}",
    "typedef Node {\n  int value;\n  byte next;\n}\n\n#define MAX_NODES 5\n\nNode nodes[MAX_NODES];\nbool used[MAX_NODES];\n\ninline my_malloc(ret) {\n  byte i = 0;\n  do\n  :: (i < MAX_NODES) ->\n      if\n      :: !used[i] ->\n          used[i] = true;\n          ret = i;\n          break\n      :: else -> i++\n      fi\n  :: else -> ret = 255; break\n  od\n}\n\ninline my_free(idx) {\n  used[idx] = false;\n}\n\ninit {\n  byte ptr;\n  my_malloc(ptr);\n  if\n  :: ptr != 255 ->\n       nodes[ptr].value = 42;\n       nodes[ptr].next = 255;\n       printf(\"Allocated node at index: %d with value: %d\\n\", ptr, nodes[ptr].value);\n       my_free(ptr);\n  :: else ->\n       printf(\"Allocation failed\\n\");\n  fi;\n}",
    "typedef Node {\n  int value;\n  int next;\n}\nNode node_mem[2];\nint head = 0;\ninit {\n  atomic {\n    node_mem[0].value = 10;\n    node_mem[0].next = 1;\n    node_mem[1].value = 20;\n    node_mem[1].next = -1;\n    int temp = head;\n    printf(\"Linked List: \");\n    do\n    :: (temp != -1) ->\n      printf(\"%d -> \", node_mem[temp].value);\n      temp = node_mem[temp].next;\n    :: (temp == -1) -> break;\n    od;\n    printf(\"NULL\\n\");\n  }\n}",
    "typedef Node {\n  int value;\n  int next;\n}\nNode node_mem[2];\nint head = 0;\ninit {\n  atomic {\n    node_mem[0].value = 10;\n    node_mem[0].next = 1;\n    node_mem[1].value = 20;\n    node_mem[1].next = -1;\n    int temp = head;\n    printf(\"Linked List: \");\n    do\n    :: (temp != -1) ->\n      printf(\"%d -> \", node_mem[temp].value);\n      temp = node_mem[temp].next;\n    :: (temp == -1) -> break;\n    od;\n    printf(\"NULL\\n\");\n  }\n}",
    "typedef Node {\n  int value;\n  int next;\n}\nNode node_mem[2];\nint head = 0;\ninit {\n  atomic {\n    node_mem[0].value = 10;\n    node_mem[0].next = 1;\n    node_mem[1].value = 20;\n    node_mem[1].next = -1;\n    int temp = head;\n    printf(\"Linked List: \");\n    do\n    :: (temp != -1) ->\n      printf(\"%d -> \", node_mem[temp].value);\n      temp = node_mem[temp].next;\n    :: (temp == -1) -> break;\n    od;\n    printf(\"NULL\\n\");\n  }\n}",
    "typedef Node {\n  int value;\n  int next;\n}\nNode node_mem[2];\nint head = 0;\ninit {\n  atomic {\n    node_mem[0].value = 10;\n    node_mem[0].next = 1;\n    node_mem[1].value = 20;\n    node_mem[1].next = -1;\n    int temp = head;\n    printf(\"Linked List: \");\n    do\n    :: (temp != -1) ->\n      printf(\"%d -> \", node_mem[temp].value);\n      temp = node_mem[temp].next;\n    :: (temp == -1) -> break;\n    od;\n    printf(\"NULL\\n\");\n  }\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int option = 2;\nproctype switch_case() {\n  if\n  :: option == 1 -> printf(\"Case 1: Option is 1\\n\");\n  :: option == 2 -> printf(\"Case 2: Option is 2\\n\");\n  :: option == 3 -> printf(\"Case 3: Option is 3\\n\");\n  :: else -> printf(\"Default Case: Option is not 1, 2, or 3\\n\");\n  fi;\n}\ninit {\n  run switch_case();\n}",
    "init {\n  run func1();\n  run func2();\n  run func3();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int i = 0;\nproctype break_example() {\n  do\n  :: (i >= 5) -> printf(\"Breaking at i = %d\\n\", i); break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run break_example();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "typedef Node {\n  int value;\n  int next;\n}\nNode node_mem[2];\nint head = 0;\ninit {\n  atomic {\n    node_mem[0].value = 10;\n    node_mem[0].next = 1;\n    node_mem[1].value = 20;\n    node_mem[1].next = -1;\n    int temp = head;\n    printf(\"Linked List: \");\n    do\n    :: (temp != -1) ->\n      printf(\"%d -> \", node_mem[temp].value);\n      temp = node_mem[temp].next;\n    :: (temp == -1) -> break;\n    od;\n    printf(\"NULL\\n\");\n  }\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "init {\n  run func1();\n  run func2();\n  run func3();\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "typedef Node {\n  int value;\n  byte next;\n}\n\n#define MAX_NODES 5\n\nNode nodes[MAX_NODES];\nbool used[MAX_NODES];\n\ninline my_malloc(ret) {\n  byte i = 0;\n  do\n  :: (i < MAX_NODES) ->\n      if\n      :: !used[i] ->\n          used[i] = true;\n          ret = i;\n          break\n      :: else -> i++\n      fi\n  :: else -> ret = 255; break\n  od\n}\n\ninline my_free(idx) {\n  used[idx] = false;\n}\n\ninit {\n  byte ptr;\n  my_malloc(ptr);\n  if\n  :: ptr != 255 ->\n       nodes[ptr].value = 42;\n       nodes[ptr].next = 255;\n       printf(\"Allocated node at index: %d with value: %d\\n\", ptr, nodes[ptr].value);\n       my_free(ptr);\n  :: else ->\n       printf(\"Allocation failed\\n\");\n  fi;\n}",
    "byte i = 0;\ndo\n:: (i < 5) ->\n  printf(\"%d\\n\", i);\n  i++;\n:: else -> break;\nod;",
    "typedef Node {\n  int value;\n  byte next;\n}\n\n#define MAX_NODES 5\n\nNode nodes[MAX_NODES];\nbool used[MAX_NODES];\n\ninline my_malloc(ret) {\n  byte i = 0;\n  do\n  :: (i < MAX_NODES) ->\n      if\n      :: !used[i] ->\n          used[i] = true;\n          ret = i;\n          break\n      :: else -> i++\n      fi\n  :: else -> ret = 255; break\n  od\n}\n\ninline my_free(idx) {\n  used[idx] = false;\n}\n\ninit {\n  byte ptr;\n  my_malloc(ptr);\n  if\n  :: ptr != 255 ->\n       nodes[ptr].value = 42;\n       nodes[ptr].next = 255;\n       printf(\"Allocated node at index: %d with value: %d\\n\", ptr, nodes[ptr].value);\n       my_free(ptr);\n  :: else ->\n       printf(\"Allocation failed\\n\");\n  fi;\n}",
    "typedef Node {\n  int value;\n  byte next;\n}\n\n#define MAX_NODES 5\n\nNode nodes[MAX_NODES];\nbool used[MAX_NODES];\n\ninline my_malloc(ret) {\n  byte i = 0;\n  do\n  :: (i < MAX_NODES) ->\n      if\n      :: !used[i] ->\n          used[i] = true;\n          ret = i;\n          break\n      :: else -> i++\n      fi\n  :: else -> ret = 255; break\n  od\n}\n\ninline my_free(idx) {\n  used[idx] = false;\n}\n\ninit {\n  byte ptr;\n  my_malloc(ptr);\n  if\n  :: ptr != 255 ->\n       nodes[ptr].value = 42;\n       nodes[ptr].next = 255;\n       printf(\"Allocated node at index: %d with value: %d\\n\", ptr, nodes[ptr].value);\n       my_free(ptr);\n  :: else ->\n       printf(\"Allocation failed\\n\");\n  fi;\n}",
    "int i = 0;\nproctype continue_example() {\n  do\n  :: (i == 2) -> i++; printf(\"Skipping i = 2\\n\");\n  :: (i >= 5) -> break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run continue_example();\n}",
    "int i = 0;\nproctype break_example() {\n  do\n  :: (i >= 5) -> printf(\"Breaking at i = %d\\n\", i); break;\n  :: printf(\"i = %d\\n\", i); i++;\n  od;\n}\ninit {\n  run break_example();\n}"
]